3.2. Деревья бинарного поиска

 - Task 1: Plan - 1.5; Fact - 2.5.
 - Task 2: Plan - 0,8; Fact - 0,5.
 - Task 3: Plan - 1; Fact - 0.6.
 - Task 4: Plan - 1; Fact - 1.

  Условия заданий:

# Task 1:
3.2.6
Добавьте в класс BST метод height() для вычисления высоты дерева. Разработайте две реализации: рекурсивный метод (требующий линейного времени и памяти, пропорциональной высоте) и метод наподобие size(), для работы которого нужно дополнительное поле в каждом узле дерева  (требующий линейного объема памяти и константного времени на запрос).
# Task 2 :
3.2.29
_Проверка бинарного дерева_. Напишите рекурсивный метод _isBinaryTree()_, который принимает в качестве аргумента узел Node и возвращает true, если счетчик узлов N для поддерева с указаным корнем верен, и false в противном случае.
# Task 3 :
3.2.36
_Итератор_. Возможно ли написать нерекурсивный вариант метода keys(), который использует память, пропорциональную высоте дерева (независимо от количества ключей в диапазоне)?
# Task 4 :
3.2.25
_Идеальная балансировка_. Напишите программу, которая вставляет набор ключей в первоначальное пустое ДБП так, что полученное дерево эквивалентно бинарному поиску — т.е. последовательность сравнений, выполняемых при поиске любого ключа в ДБП, совпадает с последовательностью сравнений, выполняемых при бинарном поиске в том же наборе ключей.